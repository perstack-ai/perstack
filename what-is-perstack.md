# AIエージェント ランタイム & サーバーレスサンドボックス基盤

## 概要

本資料では、本番環境でAIエージェントを構築・運用するための2つのシステムについて説明します：

1. **エージェントランタイム** — 決定論的な状態管理を備えたモジュラーなAIエージェント実行環境
2. **サーバーレスサンドボックス** — セキュアで隔離されたエージェント実行のためのマネージド基盤

これらを組み合わせることで **エージェント・ファースト開発** が可能になります。オーケストレーション基盤の構築ではなく、エージェントの振る舞いの定義に集中できます。

---

## 1. エージェントランタイム

従来のエージェント開発は、保守が困難で再利用不可能なモノリシックなアプリケーションを生み出してきました。エージェントランタイムは異なるモデルを導入します：

| 従来のエージェント         | 当社のエージェントランタイム             |
| -------------------------- | ---------------------------------------- |
| 多くのことを行う           | 一つのことを上手くやる                   |
| アプリケーション固有       | 目的固有、コンテキスト非依存             |
| 再利用が困難               | 組み合わせを前提とした設計               |
| コンテキストウィンドウ共有 | エージェントごとに隔離されたコンテキスト |

```toml
[experts."code-reviewer"]
description = "セキュリティ問題についてコードをレビューします。ファイルパスを指定してください。"

instruction = """
あなたはセキュリティに特化したコードレビュアーです。
潜在的な脆弱性を重要度とともに報告してください。
"""

delegates = ["security-analyst"]
```

### スキルによる機能拡張

エージェントは **スキル** を通じて外部システムと連携します。スキルはMCP（Model Context Protocol）サーバーとして実装され、エージェントにツール（関数）を提供します。

#### MCPスキル

外部サービスやシステムとの連携を担うスキルです：

| スキル例     | 提供するツール                              |
| ------------ | ------------------------------------------- |
| ファイル操作 | 読み取り、書き込み、検索、ディレクトリ操作  |
| Web検索      | 検索クエリの実行、結果の取得                |
| API連携      | Slack通知、GitHub操作、データベースアクセス |
| コード実行   | Python/JavaScript等のサンドボックス実行     |

スキルは最小権限の原則に従い、必要な環境変数（`requiredEnv`）のみがスキルに渡されます。

#### Interactiveスキル

ユーザーとの対話が必要な操作を担うスキルです：

- **確認要求** — 重要な操作の実行前にユーザー承認を取得
- **情報収集** — 追加情報をユーザーに問い合わせ
- **選択肢提示** — 複数の選択肢からユーザーに選択させる

Interactiveスキルが呼び出されると、ジョブは一時停止し、ユーザーの応答を待機します。これにより **human-in-the-loop** パターンが実現されます。

```
エージェント実行中
    │
    ├─ Interactiveスキル呼び出し
    │       │
    │       ▼
    │   ジョブ一時停止 ──→ ユーザーに通知
    │                           │
    │                     ユーザーが応答
    │                           │
    │       ◄───────────────────┘
    │
    ├─ 応答を受けて実行再開
    ▼
```

---

## 2. サーバーレスサンドボックス基盤

### アーキテクチャ

```
┌─────────────────────────────────────────────────────┐
│  アプリケーション                                    │
│  - ユーザー入力の受信                                │
│  - エージェント出力の表示                            │
│  - 承認フロー（human-in-the-loop）                  │
└──────────────┬──────────────────────────────────────┘
               │ API呼び出し
┌──────────────▼──────────────────────────────────────┐
│  Serverless Sandbox API                             │
│  ┌────────────────────────────────────────────────┐ │
│  │  Expert Job管理                                │ │
│  │  - ジョブライフサイクル（作成、継続、キャンセル）  │ │
│  │  - チェックポイントストリーミング（SSE）          │ │
│  │  - ワークスペースインスタンス管理                 │ │
│  └────────────────────────────────────────────────┘ │
└──────────────┬──────────────────────────────────────┘
               │ ディスパッチ
┌──────────────▼──────────────────────────────────────┐
│  Fly.io マシンプール                                 │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐               │
│  │ Runner  │ │ Runner  │ │ Runner  │  ...          │
│  │(suspend)│ │(suspend)│ │(running)│               │
│  └─────────┘ └─────────┘ └─────────┘               │
│                                                     │
│  - 即時起動のためのサスペンド済みマシンプール          │
│  - 需要に応じた自動スケーリング                       │
│  - 実行ごとに隔離されたコンテナ                       │
└─────────────────────────────────────────────────────┘
```

### 主要コンポーネント

#### Expert Job API

| エンドポイント                            | 説明                                               |
| ----------------------------------------- | -------------------------------------------------- |
| `POST /expert_jobs`                       | 新規エージェント実行を開始                         |
| `POST /expert_jobs/:id/continue`          | チェックポイントから継続（人間の入力、再開）       |
| `GET /expert_jobs/:id/checkpoints/stream` | 実行イベントのリアルタイムSSEストリーム            |
| `GET /expert_jobs/:id/workspace_instance` | ジョブごとの隔離されたファイルストレージにアクセス |

#### ワークスペース分離

各ジョブは隔離されたワークスペースインスタンスを受け取ります：

- **ユーザーファイル** — ユーザーが提供した読み取り専用の入力
- **エージェントファイル** — 実行中に作成されたファイル
- **チェックポイントデータ** — リプレイのための実行履歴
- **環境シークレット** — 暗号化された認証情報（アプリケーションごと）

#### Runnerプール管理

即時ジョブディスパッチのために **サスペンド済みマシン** のプールを維持します：

1. **ジョブ到着** → サスペンドマシンを起動（コールドスタート約100ms）
2. **ジョブ完了** → マシンはサスペンドプールに戻る
3. **プール枯渇** → 新規マシンをオンデマンドで作成
4. **マシン過剰** → 最も古いサスペンドマシンを停止

これにより、アイドルコストを最小化しながら、ほぼ即時のジョブ開始を実現します。

---

## 3. セキュリティモデル

### サンドボックス・ファースト・アプローチ

従来のエージェントセキュリティは、エージェントにできることを制限します。これは軍拡競争を生み出します — より高機能なエージェントには、より多くの制限が必要になります。

サンドボックス・ファースト・アプローチはこれを逆転させます：**エージェントを境界内で自由に動作させ、実行後に振る舞いを検証する**。

| レイヤー     | 脅威                   | 緩和策                                          |
| ------------ | ---------------------- | ----------------------------------------------- |
| プロンプト   | インジェクション、汚染 | 事後検証のための完全な可観測性                  |
| ツール(MCP)  | 権限濫用               | 最小権限の`requiredEnv`、明示的なスキル割り当て |
| ランタイム   | ホスト侵害             | コンテナ分離（実行ごと）                        |
| ネットワーク | データ流出             | イベントベースの出力。直接の外部接続なし        |

### 多層防御

```
セキュリティレベル

     ↑ 安全
     │
     │  ┌─────────────────────────────────────────────┐
     │  │  インフラストラクチャ制御                     │
     │  │  - コンテナ分離（ジョブごと）                 │
     │  │  - ネットワーク制限                          │
     │  │  - Human-in-the-loop承認                    │
     │  └─────────────────────────────────────────────┘
     │  ┌─────────────────────────────────────────────┐
     │  │  ランタイム保護（自動）                       │
     │  │  - ワークスペース境界の強制                   │
     │  │  - スキル分離（requiredEnv）                 │
     │  │  - イベントベース出力（直接ネットワークなし）   │
     │  │  - 完全な監査証跡                            │
     │  └─────────────────────────────────────────────┘
     │
     ↓ 危険
```

---

## 4. なぜこのアーキテクチャか？

### 同居問題

従来のエージェントフレームワークは、エージェントをAPIサーバー内で実行します。これは競合を生み出します：

| APIサーバーが求めるもの   | エージェントが求めるもの     |
| ------------------------- | ---------------------------- |
| 高速レスポンス（< 100ms） | 長時間の実行（秒〜分単位）   |
| 低メモリフットプリント    | 大きなコンテキストウィンドウ |
| 高い並行性                | 推論中の専用CPU              |
| ステートレスなリクエスト  | 永続的な会話状態             |

### 分離による解決

このアーキテクチャは、インフラストラクチャの複雑さなしに分離を提供します：

- **実行ごとのコンテナ** — エージェント間、またはAPIとのリソース競合なし
- **標準出力イベント** — WebSocket基盤不要。コンテナ出力を読むだけ
- **チェックポイントファイル** — 外部状態ストア不要。状態はワークスペースに保存
- **シンプルなインターフェース** — API呼び出しでジョブをディスパッチ。SSEストリームでイベントを受信

---

## 5. デプロイメントパターン

### ユーザーごとの分離

各ユーザーは専用のワークスペースを持ちます。エージェントはそのワークスペースにのみ読み書きします。

```
/workspaces/
├── user-alice/
│   ├── documents/
│   └── .runtime/       ← チェックポイント、イベント
├── user-bob/
│   ├── documents/
│   └── .runtime/
```

### マルチエージェント・オーケストレーション

アプリケーションは複数のExpert Jobをオーケストレーションできます：

1. **シーケンシャル** — Job A完了 → Job Aの結果でJob Bを開始
2. **パラレル** — Job A, B, Cを同時に開始 → 結果を集約
3. **インタラクティブ** — ジョブが人間の入力を待機 → ユーザーの応答で継続

Coordinator Expertパターンは、委譲を通じて単一のジョブ内で複雑なワークフローを処理します。

---

## まとめ

| 課題               | 解決策                                         |
| ------------------ | ---------------------------------------------- |
| エージェント定義   | 宣言的TOML（コード不要）                       |
| 実行環境           | ジョブごとに隔離されたコンテナ                 |
| 状態管理           | 決定論的チェックポイント                       |
| セキュリティ       | 完全な可観測性を伴うサンドボックス・ファースト |
| スケーラビリティ   | 自動スケーリング付きプリウォームマシンプール   |
| インテグレーション | REST API + SSEストリーミング                   |
| 再利用性           | Expertレジストリ（npm形式での公開）            |

このアーキテクチャにより、以下を備えた本番品質のAIエージェントアプリケーションの構築が可能になります：

- **Isolation** — エージェント、ユーザー、アプリケーション間の明確な分離
- **Observability** — すべてのエージェントの判断とアクションの完全な監査証跡
- **Reusability** — 実証済みのモジュラーコンポーネントからエージェントを構成

