import { z } from "zod"
import type {
  FileBinaryPart,
  FileInlinePart,
  FileUrlPart,
  ImageBinaryPart,
  ImageInlinePart,
  ImageUrlPart,
  TextPart,
  ToolCallPart,
  ToolResultPart,
} from "./message-part.js"
import {
  fileBinaryPartSchema,
  fileInlinePartSchema,
  fileUrlPartSchema,
  imageBinaryPartSchema,
  imageInlinePartSchema,
  imageUrlPartSchema,
  textPartSchema,
  toolCallPartSchema,
  toolResultPartSchema,
} from "./message-part.js"

/** Base properties shared by all messages */
interface BaseMessage {
  /** Unique identifier for this message */
  id: string
}

const baseMessageSchema = z.object({
  id: z.string(),
})

/** System instruction message sent at the start of a conversation */
export interface InstructionMessage extends BaseMessage {
  type: "instructionMessage"
  /** Text content of the instruction */
  contents: TextPart[]
  /** Whether to cache this message for prompt caching */
  cache?: boolean
}

export const instructionMessageSchema = baseMessageSchema.extend({
  type: z.literal("instructionMessage"),
  contents: z.array(textPartSchema),
  cache: z.boolean().optional(),
})
instructionMessageSchema satisfies z.ZodType<InstructionMessage>

/** Message from the user (human or system providing input) */
export interface UserMessage extends BaseMessage {
  type: "userMessage"
  /** Content of the user message (text, images, or files) */
  contents: (
    | TextPart
    | ImageUrlPart
    | ImageInlinePart
    | ImageBinaryPart
    | FileUrlPart
    | FileInlinePart
    | FileBinaryPart
  )[]
  /** Whether to cache this message for prompt caching */
  cache?: boolean
}

export const userMessageSchema = baseMessageSchema.extend({
  type: z.literal("userMessage"),
  contents: z.array(
    z.union([
      textPartSchema,
      imageUrlPartSchema,
      imageInlinePartSchema,
      imageBinaryPartSchema,
      fileUrlPartSchema,
      fileInlinePartSchema,
      fileBinaryPartSchema,
    ]),
  ),
  cache: z.boolean().optional(),
})
userMessageSchema satisfies z.ZodType<UserMessage>

/** Message generated by the Expert (LLM response) */
export interface ExpertMessage extends BaseMessage {
  type: "expertMessage"
  /** Content generated by the Expert (text or tool calls) */
  contents: (TextPart | ToolCallPart)[]
  /** Whether to cache this message for prompt caching */
  cache?: boolean
}

export const expertMessageSchema = baseMessageSchema.extend({
  type: z.literal("expertMessage"),
  contents: z.array(z.union([textPartSchema, toolCallPartSchema])),
  cache: z.boolean().optional(),
})
expertMessageSchema satisfies z.ZodType<ExpertMessage>

/** Message containing tool execution results */
export interface ToolMessage extends BaseMessage {
  type: "toolMessage"
  /** Tool result contents */
  contents: ToolResultPart[]
  /** Whether to cache this message for prompt caching */
  cache?: boolean
}

export const toolMessageSchema = baseMessageSchema.extend({
  type: z.literal("toolMessage"),
  contents: z.array(toolResultPartSchema),
  cache: z.boolean().optional(),
})
toolMessageSchema satisfies z.ZodType<ToolMessage>

/** All possible message types */
export type Message = InstructionMessage | UserMessage | ExpertMessage | ToolMessage

export const messageSchema = z.union([
  instructionMessageSchema,
  userMessageSchema,
  expertMessageSchema,
  toolMessageSchema,
])
